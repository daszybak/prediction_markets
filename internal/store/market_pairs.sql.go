// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: market_pairs.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteMarketPair = `-- name: DeleteMarketPair :exec
DELETE FROM market_pairs WHERE market_id_a = $1 AND market_id_b = $2
`

type DeleteMarketPairParams struct {
	MarketIDA string `json:"market_id_a"`
	MarketIDB string `json:"market_id_b"`
}

func (q *Queries) DeleteMarketPair(ctx context.Context, arg DeleteMarketPairParams) error {
	_, err := q.db.Exec(ctx, deleteMarketPair, arg.MarketIDA, arg.MarketIDB)
	return err
}

const getEquivalentMarkets = `-- name: GetEquivalentMarkets :many
SELECT market_id_a, market_id_b, is_equivalent, confidence, verified_by, llm_model, llm_reasoning, verified_at FROM market_pairs
WHERE (market_id_a = $1 OR market_id_b = $1) AND is_equivalent = true
`

func (q *Queries) GetEquivalentMarkets(ctx context.Context, marketIDA string) ([]MarketPair, error) {
	rows, err := q.db.Query(ctx, getEquivalentMarkets, marketIDA)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MarketPair
	for rows.Next() {
		var i MarketPair
		if err := rows.Scan(
			&i.MarketIDA,
			&i.MarketIDB,
			&i.IsEquivalent,
			&i.Confidence,
			&i.VerifiedBy,
			&i.LlmModel,
			&i.LlmReasoning,
			&i.VerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMarketPair = `-- name: GetMarketPair :one
SELECT market_id_a, market_id_b, is_equivalent, confidence, verified_by, llm_model, llm_reasoning, verified_at FROM market_pairs WHERE market_id_a = $1 AND market_id_b = $2
`

type GetMarketPairParams struct {
	MarketIDA string `json:"market_id_a"`
	MarketIDB string `json:"market_id_b"`
}

func (q *Queries) GetMarketPair(ctx context.Context, arg GetMarketPairParams) (MarketPair, error) {
	row := q.db.QueryRow(ctx, getMarketPair, arg.MarketIDA, arg.MarketIDB)
	var i MarketPair
	err := row.Scan(
		&i.MarketIDA,
		&i.MarketIDB,
		&i.IsEquivalent,
		&i.Confidence,
		&i.VerifiedBy,
		&i.LlmModel,
		&i.LlmReasoning,
		&i.VerifiedAt,
	)
	return i, err
}

const listUnverifiedPairs = `-- name: ListUnverifiedPairs :many
SELECT market_id_a, market_id_b, is_equivalent, confidence, verified_by, llm_model, llm_reasoning, verified_at FROM market_pairs
WHERE verified_by = 'embedding'
ORDER BY confidence DESC
LIMIT $1
`

func (q *Queries) ListUnverifiedPairs(ctx context.Context, limit int32) ([]MarketPair, error) {
	rows, err := q.db.Query(ctx, listUnverifiedPairs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MarketPair
	for rows.Next() {
		var i MarketPair
		if err := rows.Scan(
			&i.MarketIDA,
			&i.MarketIDB,
			&i.IsEquivalent,
			&i.Confidence,
			&i.VerifiedBy,
			&i.LlmModel,
			&i.LlmReasoning,
			&i.VerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertMarketPair = `-- name: UpsertMarketPair :exec
INSERT INTO market_pairs (market_id_a, market_id_b, is_equivalent, confidence, verified_by, llm_model, llm_reasoning, verified_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
ON CONFLICT (market_id_a, market_id_b) DO UPDATE SET
    is_equivalent = EXCLUDED.is_equivalent,
    confidence = EXCLUDED.confidence,
    verified_by = EXCLUDED.verified_by,
    llm_model = EXCLUDED.llm_model,
    llm_reasoning = EXCLUDED.llm_reasoning,
    verified_at = NOW()
`

type UpsertMarketPairParams struct {
	MarketIDA    string      `json:"market_id_a"`
	MarketIDB    string      `json:"market_id_b"`
	IsEquivalent bool        `json:"is_equivalent"`
	Confidence   float64     `json:"confidence"`
	VerifiedBy   string      `json:"verified_by"`
	LlmModel     pgtype.Text `json:"llm_model"`
	LlmReasoning pgtype.Text `json:"llm_reasoning"`
}

func (q *Queries) UpsertMarketPair(ctx context.Context, arg UpsertMarketPairParams) error {
	_, err := q.db.Exec(ctx, upsertMarketPair,
		arg.MarketIDA,
		arg.MarketIDB,
		arg.IsEquivalent,
		arg.Confidence,
		arg.VerifiedBy,
		arg.LlmModel,
		arg.LlmReasoning,
	)
	return err
}
