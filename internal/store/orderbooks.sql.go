// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orderbooks.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getLatestOrderBookMetrics = `-- name: GetLatestOrderBookMetrics :one
SELECT time, token_id, mid_price, best_bid, best_ask, spread, spread_bps, bid_depth_5, ask_depth_5, bid_depth_10, ask_depth_10, imbalance FROM order_book_metrics
WHERE token_id = $1
ORDER BY time DESC
LIMIT 1
`

func (q *Queries) GetLatestOrderBookMetrics(ctx context.Context, tokenID string) (OrderBookMetric, error) {
	row := q.db.QueryRow(ctx, getLatestOrderBookMetrics, tokenID)
	var i OrderBookMetric
	err := row.Scan(
		&i.Time,
		&i.TokenID,
		&i.MidPrice,
		&i.BestBid,
		&i.BestAsk,
		&i.Spread,
		&i.SpreadBps,
		&i.BidDepth5,
		&i.AskDepth5,
		&i.BidDepth10,
		&i.AskDepth10,
		&i.Imbalance,
	)
	return i, err
}

const getLatestOrderBookSnapshot = `-- name: GetLatestOrderBookSnapshot :many
SELECT time, token_id, side, level, price, size FROM order_book_snapshots obs
WHERE obs.token_id = $1
AND obs.time = (SELECT MAX(sub.time) FROM order_book_snapshots sub WHERE sub.token_id = $1)
ORDER BY obs.side, obs.level
`

func (q *Queries) GetLatestOrderBookSnapshot(ctx context.Context, tokenID string) ([]OrderBookSnapshot, error) {
	rows, err := q.db.Query(ctx, getLatestOrderBookSnapshot, tokenID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderBookSnapshot
	for rows.Next() {
		var i OrderBookSnapshot
		if err := rows.Scan(
			&i.Time,
			&i.TokenID,
			&i.Side,
			&i.Level,
			&i.Price,
			&i.Size,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderBookMetricsRange = `-- name: GetOrderBookMetricsRange :many
SELECT time, token_id, mid_price, best_bid, best_ask, spread, spread_bps, bid_depth_5, ask_depth_5, bid_depth_10, ask_depth_10, imbalance FROM order_book_metrics
WHERE token_id = $1 AND time >= $2 AND time <= $3
ORDER BY time DESC
`

type GetOrderBookMetricsRangeParams struct {
	TokenID string             `json:"token_id"`
	Time    pgtype.Timestamptz `json:"time"`
	Time_2  pgtype.Timestamptz `json:"time_2"`
}

func (q *Queries) GetOrderBookMetricsRange(ctx context.Context, arg GetOrderBookMetricsRangeParams) ([]OrderBookMetric, error) {
	rows, err := q.db.Query(ctx, getOrderBookMetricsRange, arg.TokenID, arg.Time, arg.Time_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderBookMetric
	for rows.Next() {
		var i OrderBookMetric
		if err := rows.Scan(
			&i.Time,
			&i.TokenID,
			&i.MidPrice,
			&i.BestBid,
			&i.BestAsk,
			&i.Spread,
			&i.SpreadBps,
			&i.BidDepth5,
			&i.AskDepth5,
			&i.BidDepth10,
			&i.AskDepth10,
			&i.Imbalance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrderBookMetrics = `-- name: InsertOrderBookMetrics :exec
INSERT INTO order_book_metrics (
    time, token_id, mid_price, best_bid, best_ask, spread, spread_bps,
    bid_depth_5, ask_depth_5, bid_depth_10, ask_depth_10, imbalance
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
`

type InsertOrderBookMetricsParams struct {
	Time       pgtype.Timestamptz `json:"time"`
	TokenID    string             `json:"token_id"`
	MidPrice   pgtype.Int8        `json:"mid_price"`
	BestBid    pgtype.Int8        `json:"best_bid"`
	BestAsk    pgtype.Int8        `json:"best_ask"`
	Spread     pgtype.Int8        `json:"spread"`
	SpreadBps  pgtype.Int2        `json:"spread_bps"`
	BidDepth5  pgtype.Int8        `json:"bid_depth_5"`
	AskDepth5  pgtype.Int8        `json:"ask_depth_5"`
	BidDepth10 pgtype.Int8        `json:"bid_depth_10"`
	AskDepth10 pgtype.Int8        `json:"ask_depth_10"`
	Imbalance  pgtype.Int2        `json:"imbalance"`
}

func (q *Queries) InsertOrderBookMetrics(ctx context.Context, arg InsertOrderBookMetricsParams) error {
	_, err := q.db.Exec(ctx, insertOrderBookMetrics,
		arg.Time,
		arg.TokenID,
		arg.MidPrice,
		arg.BestBid,
		arg.BestAsk,
		arg.Spread,
		arg.SpreadBps,
		arg.BidDepth5,
		arg.AskDepth5,
		arg.BidDepth10,
		arg.AskDepth10,
		arg.Imbalance,
	)
	return err
}

type InsertOrderBookMetricsBatchParams struct {
	Time       pgtype.Timestamptz `json:"time"`
	TokenID    string             `json:"token_id"`
	MidPrice   pgtype.Int8        `json:"mid_price"`
	BestBid    pgtype.Int8        `json:"best_bid"`
	BestAsk    pgtype.Int8        `json:"best_ask"`
	Spread     pgtype.Int8        `json:"spread"`
	SpreadBps  pgtype.Int2        `json:"spread_bps"`
	BidDepth5  pgtype.Int8        `json:"bid_depth_5"`
	AskDepth5  pgtype.Int8        `json:"ask_depth_5"`
	BidDepth10 pgtype.Int8        `json:"bid_depth_10"`
	AskDepth10 pgtype.Int8        `json:"ask_depth_10"`
	Imbalance  pgtype.Int2        `json:"imbalance"`
}

const insertOrderBookSnapshot = `-- name: InsertOrderBookSnapshot :exec
INSERT INTO order_book_snapshots (time, token_id, side, level, price, size)
VALUES ($1, $2, $3, $4, $5, $6)
`

type InsertOrderBookSnapshotParams struct {
	Time    pgtype.Timestamptz `json:"time"`
	TokenID string             `json:"token_id"`
	Side    string             `json:"side"`
	Level   int16              `json:"level"`
	Price   int64              `json:"price"`
	Size    int64              `json:"size"`
}

func (q *Queries) InsertOrderBookSnapshot(ctx context.Context, arg InsertOrderBookSnapshotParams) error {
	_, err := q.db.Exec(ctx, insertOrderBookSnapshot,
		arg.Time,
		arg.TokenID,
		arg.Side,
		arg.Level,
		arg.Price,
		arg.Size,
	)
	return err
}

type InsertOrderBookSnapshotBatchParams struct {
	Time    pgtype.Timestamptz `json:"time"`
	TokenID string             `json:"token_id"`
	Side    string             `json:"side"`
	Level   int16              `json:"level"`
	Price   int64              `json:"price"`
	Size    int64              `json:"size"`
}
