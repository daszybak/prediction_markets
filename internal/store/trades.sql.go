// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: trades.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getTradeByID = `-- name: GetTradeByID :one
SELECT time, token_id, trade_id, price, size, side, maker, taker FROM trades WHERE trade_id = $1
`

func (q *Queries) GetTradeByID(ctx context.Context, tradeID pgtype.Text) (Trade, error) {
	row := q.db.QueryRow(ctx, getTradeByID, tradeID)
	var i Trade
	err := row.Scan(
		&i.Time,
		&i.TokenID,
		&i.TradeID,
		&i.Price,
		&i.Size,
		&i.Side,
		&i.Maker,
		&i.Taker,
	)
	return i, err
}

const getTradesByToken = `-- name: GetTradesByToken :many
SELECT time, token_id, trade_id, price, size, side, maker, taker FROM trades
WHERE token_id = $1
ORDER BY time DESC
LIMIT $2
`

type GetTradesByTokenParams struct {
	TokenID string `json:"token_id"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) GetTradesByToken(ctx context.Context, arg GetTradesByTokenParams) ([]Trade, error) {
	rows, err := q.db.Query(ctx, getTradesByToken, arg.TokenID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trade
	for rows.Next() {
		var i Trade
		if err := rows.Scan(
			&i.Time,
			&i.TokenID,
			&i.TradeID,
			&i.Price,
			&i.Size,
			&i.Side,
			&i.Maker,
			&i.Taker,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTradesRange = `-- name: GetTradesRange :many
SELECT time, token_id, trade_id, price, size, side, maker, taker FROM trades
WHERE token_id = $1 AND time >= $2 AND time <= $3
ORDER BY time DESC
`

type GetTradesRangeParams struct {
	TokenID string             `json:"token_id"`
	Time    pgtype.Timestamptz `json:"time"`
	Time_2  pgtype.Timestamptz `json:"time_2"`
}

func (q *Queries) GetTradesRange(ctx context.Context, arg GetTradesRangeParams) ([]Trade, error) {
	rows, err := q.db.Query(ctx, getTradesRange, arg.TokenID, arg.Time, arg.Time_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trade
	for rows.Next() {
		var i Trade
		if err := rows.Scan(
			&i.Time,
			&i.TokenID,
			&i.TradeID,
			&i.Price,
			&i.Size,
			&i.Side,
			&i.Maker,
			&i.Taker,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTrade = `-- name: InsertTrade :exec
INSERT INTO trades (time, token_id, trade_id, price, size, side, maker, taker)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type InsertTradeParams struct {
	Time    pgtype.Timestamptz `json:"time"`
	TokenID string             `json:"token_id"`
	TradeID pgtype.Text        `json:"trade_id"`
	Price   int64              `json:"price"`
	Size    int64              `json:"size"`
	Side    string             `json:"side"`
	Maker   pgtype.Text        `json:"maker"`
	Taker   pgtype.Text        `json:"taker"`
}

func (q *Queries) InsertTrade(ctx context.Context, arg InsertTradeParams) error {
	_, err := q.db.Exec(ctx, insertTrade,
		arg.Time,
		arg.TokenID,
		arg.TradeID,
		arg.Price,
		arg.Size,
		arg.Side,
		arg.Maker,
		arg.Taker,
	)
	return err
}

type InsertTradeBatchParams struct {
	Time    pgtype.Timestamptz `json:"time"`
	TokenID string             `json:"token_id"`
	TradeID pgtype.Text        `json:"trade_id"`
	Price   int64              `json:"price"`
	Size    int64              `json:"size"`
	Side    string             `json:"side"`
	Maker   pgtype.Text        `json:"maker"`
	Taker   pgtype.Text        `json:"taker"`
}
