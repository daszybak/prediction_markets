// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: news_articles.sql

package store

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const deleteNewsArticle = `-- name: DeleteNewsArticle :exec
DELETE FROM news_articles WHERE id = $1
`

func (q *Queries) DeleteNewsArticle(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteNewsArticle, id)
	return err
}

const findSimilarNewsByHeadline = `-- name: FindSimilarNewsByHeadline :many
SELECT id, headline, headline_embedding <=> $1 AS distance
FROM news_articles
WHERE headline_embedding IS NOT NULL
ORDER BY distance
LIMIT $2
`

type FindSimilarNewsByHeadlineParams struct {
	HeadlineEmbedding pgvector.Vector `json:"headline_embedding"`
	Limit             int32           `json:"limit"`
}

type FindSimilarNewsByHeadlineRow struct {
	ID       int32       `json:"id"`
	Headline string      `json:"headline"`
	Distance interface{} `json:"distance"`
}

func (q *Queries) FindSimilarNewsByHeadline(ctx context.Context, arg FindSimilarNewsByHeadlineParams) ([]FindSimilarNewsByHeadlineRow, error) {
	rows, err := q.db.Query(ctx, findSimilarNewsByHeadline, arg.HeadlineEmbedding, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindSimilarNewsByHeadlineRow
	for rows.Next() {
		var i FindSimilarNewsByHeadlineRow
		if err := rows.Scan(&i.ID, &i.Headline, &i.Distance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewsArticle = `-- name: GetNewsArticle :one
SELECT id, source, source_tier, url, headline, content, headline_embedding, published_at, processed_at, created_at FROM news_articles WHERE id = $1
`

func (q *Queries) GetNewsArticle(ctx context.Context, id int32) (NewsArticle, error) {
	row := q.db.QueryRow(ctx, getNewsArticle, id)
	var i NewsArticle
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.SourceTier,
		&i.Url,
		&i.Headline,
		&i.Content,
		&i.HeadlineEmbedding,
		&i.PublishedAt,
		&i.ProcessedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getNewsArticleByURL = `-- name: GetNewsArticleByURL :one
SELECT id, source, source_tier, url, headline, content, headline_embedding, published_at, processed_at, created_at FROM news_articles WHERE url = $1
`

func (q *Queries) GetNewsArticleByURL(ctx context.Context, url pgtype.Text) (NewsArticle, error) {
	row := q.db.QueryRow(ctx, getNewsArticleByURL, url)
	var i NewsArticle
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.SourceTier,
		&i.Url,
		&i.Headline,
		&i.Content,
		&i.HeadlineEmbedding,
		&i.PublishedAt,
		&i.ProcessedAt,
		&i.CreatedAt,
	)
	return i, err
}

const insertNewsArticle = `-- name: InsertNewsArticle :one
INSERT INTO news_articles (source, source_tier, url, headline, content, headline_embedding, published_at, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
RETURNING id
`

type InsertNewsArticleParams struct {
	Source            string          `json:"source"`
	SourceTier        string          `json:"source_tier"`
	Url               pgtype.Text     `json:"url"`
	Headline          string          `json:"headline"`
	Content           pgtype.Text     `json:"content"`
	HeadlineEmbedding pgvector.Vector `json:"headline_embedding"`
	PublishedAt       time.Time       `json:"published_at"`
}

func (q *Queries) InsertNewsArticle(ctx context.Context, arg InsertNewsArticleParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertNewsArticle,
		arg.Source,
		arg.SourceTier,
		arg.Url,
		arg.Headline,
		arg.Content,
		arg.HeadlineEmbedding,
		arg.PublishedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const listRecentNewsArticles = `-- name: ListRecentNewsArticles :many
SELECT id, source, source_tier, url, headline, content, headline_embedding, published_at, processed_at, created_at FROM news_articles
ORDER BY published_at DESC
LIMIT $1 OFFSET $2
`

type ListRecentNewsArticlesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListRecentNewsArticles(ctx context.Context, arg ListRecentNewsArticlesParams) ([]NewsArticle, error) {
	rows, err := q.db.Query(ctx, listRecentNewsArticles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsArticle
	for rows.Next() {
		var i NewsArticle
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.SourceTier,
			&i.Url,
			&i.Headline,
			&i.Content,
			&i.HeadlineEmbedding,
			&i.PublishedAt,
			&i.ProcessedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnprocessedNewsArticles = `-- name: ListUnprocessedNewsArticles :many
SELECT id, source, source_tier, url, headline, content, headline_embedding, published_at, processed_at, created_at FROM news_articles
WHERE processed_at IS NULL
ORDER BY published_at DESC
LIMIT $1
`

func (q *Queries) ListUnprocessedNewsArticles(ctx context.Context, limit int32) ([]NewsArticle, error) {
	rows, err := q.db.Query(ctx, listUnprocessedNewsArticles, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsArticle
	for rows.Next() {
		var i NewsArticle
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.SourceTier,
			&i.Url,
			&i.Headline,
			&i.Content,
			&i.HeadlineEmbedding,
			&i.PublishedAt,
			&i.ProcessedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNewsArticleProcessed = `-- name: MarkNewsArticleProcessed :exec
UPDATE news_articles SET processed_at = NOW() WHERE id = $1
`

func (q *Queries) MarkNewsArticleProcessed(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, markNewsArticleProcessed, id)
	return err
}
