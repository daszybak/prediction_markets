// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: news_market_links.sql

package store

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteNewsMarketLink = `-- name: DeleteNewsMarketLink :exec
DELETE FROM news_market_links WHERE news_id = $1 AND market_id = $2
`

type DeleteNewsMarketLinkParams struct {
	NewsID   int32  `json:"news_id"`
	MarketID string `json:"market_id"`
}

func (q *Queries) DeleteNewsMarketLink(ctx context.Context, arg DeleteNewsMarketLinkParams) error {
	_, err := q.db.Exec(ctx, deleteNewsMarketLink, arg.NewsID, arg.MarketID)
	return err
}

const getLinksForMarket = `-- name: GetLinksForMarket :many
SELECT news_id, market_id, similarity_score, llm_analyzed, direction, impact_magnitude, llm_confidence, llm_reasoning, created_at FROM news_market_links
WHERE market_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetLinksForMarketParams struct {
	MarketID string `json:"market_id"`
	Limit    int32  `json:"limit"`
}

func (q *Queries) GetLinksForMarket(ctx context.Context, arg GetLinksForMarketParams) ([]NewsMarketLink, error) {
	rows, err := q.db.Query(ctx, getLinksForMarket, arg.MarketID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsMarketLink
	for rows.Next() {
		var i NewsMarketLink
		if err := rows.Scan(
			&i.NewsID,
			&i.MarketID,
			&i.SimilarityScore,
			&i.LlmAnalyzed,
			&i.Direction,
			&i.ImpactMagnitude,
			&i.LlmConfidence,
			&i.LlmReasoning,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinksForNews = `-- name: GetLinksForNews :many
SELECT news_id, market_id, similarity_score, llm_analyzed, direction, impact_magnitude, llm_confidence, llm_reasoning, created_at FROM news_market_links
WHERE news_id = $1
ORDER BY similarity_score DESC
`

func (q *Queries) GetLinksForNews(ctx context.Context, newsID int32) ([]NewsMarketLink, error) {
	rows, err := q.db.Query(ctx, getLinksForNews, newsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsMarketLink
	for rows.Next() {
		var i NewsMarketLink
		if err := rows.Scan(
			&i.NewsID,
			&i.MarketID,
			&i.SimilarityScore,
			&i.LlmAnalyzed,
			&i.Direction,
			&i.ImpactMagnitude,
			&i.LlmConfidence,
			&i.LlmReasoning,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewsMarketLink = `-- name: GetNewsMarketLink :one
SELECT news_id, market_id, similarity_score, llm_analyzed, direction, impact_magnitude, llm_confidence, llm_reasoning, created_at FROM news_market_links WHERE news_id = $1 AND market_id = $2
`

type GetNewsMarketLinkParams struct {
	NewsID   int32  `json:"news_id"`
	MarketID string `json:"market_id"`
}

func (q *Queries) GetNewsMarketLink(ctx context.Context, arg GetNewsMarketLinkParams) (NewsMarketLink, error) {
	row := q.db.QueryRow(ctx, getNewsMarketLink, arg.NewsID, arg.MarketID)
	var i NewsMarketLink
	err := row.Scan(
		&i.NewsID,
		&i.MarketID,
		&i.SimilarityScore,
		&i.LlmAnalyzed,
		&i.Direction,
		&i.ImpactMagnitude,
		&i.LlmConfidence,
		&i.LlmReasoning,
		&i.CreatedAt,
	)
	return i, err
}

const listUnanalyzedLinks = `-- name: ListUnanalyzedLinks :many
SELECT news_id, market_id, similarity_score, llm_analyzed, direction, impact_magnitude, llm_confidence, llm_reasoning, created_at FROM news_market_links
WHERE llm_analyzed = false
ORDER BY similarity_score DESC
LIMIT $1
`

func (q *Queries) ListUnanalyzedLinks(ctx context.Context, limit int32) ([]NewsMarketLink, error) {
	rows, err := q.db.Query(ctx, listUnanalyzedLinks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsMarketLink
	for rows.Next() {
		var i NewsMarketLink
		if err := rows.Scan(
			&i.NewsID,
			&i.MarketID,
			&i.SimilarityScore,
			&i.LlmAnalyzed,
			&i.Direction,
			&i.ImpactMagnitude,
			&i.LlmConfidence,
			&i.LlmReasoning,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertNewsMarketLink = `-- name: UpsertNewsMarketLink :exec
INSERT INTO news_market_links (news_id, market_id, similarity_score, llm_analyzed, direction, impact_magnitude, llm_confidence, llm_reasoning, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
ON CONFLICT (news_id, market_id) DO UPDATE SET
    similarity_score = EXCLUDED.similarity_score,
    llm_analyzed = EXCLUDED.llm_analyzed,
    direction = EXCLUDED.direction,
    impact_magnitude = EXCLUDED.impact_magnitude,
    llm_confidence = EXCLUDED.llm_confidence,
    llm_reasoning = EXCLUDED.llm_reasoning
`

type UpsertNewsMarketLinkParams struct {
	NewsID          int32         `json:"news_id"`
	MarketID        string        `json:"market_id"`
	SimilarityScore float64       `json:"similarity_score"`
	LlmAnalyzed     bool          `json:"llm_analyzed"`
	Direction       pgtype.Text   `json:"direction"`
	ImpactMagnitude pgtype.Text   `json:"impact_magnitude"`
	LlmConfidence   pgtype.Float8 `json:"llm_confidence"`
	LlmReasoning    pgtype.Text   `json:"llm_reasoning"`
}

func (q *Queries) UpsertNewsMarketLink(ctx context.Context, arg UpsertNewsMarketLinkParams) error {
	_, err := q.db.Exec(ctx, upsertNewsMarketLink,
		arg.NewsID,
		arg.MarketID,
		arg.SimilarityScore,
		arg.LlmAnalyzed,
		arg.Direction,
		arg.ImpactMagnitude,
		arg.LlmConfidence,
		arg.LlmReasoning,
	)
	return err
}
